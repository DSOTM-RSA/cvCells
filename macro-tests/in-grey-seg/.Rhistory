coord_fixed() +
ggforce::theme_no_axes()
ggraph(graph = irisDen2, layout = 'dendrogram', repel = FALSE, circular = TRUE,
ratio = 0.5) +
geom_edge_elbow() +
geom_node_text(aes(x = x*1.05, y=y*1.05, filter=leaf,
angle = nAngle(x, y), label = label),
size=3, hjust='outward') +
geom_node_point(aes(leaf, color=species)) +
coord_fixed() +
ggforce::theme_no_axes()
ggraph(graph = irisDen2, layout = 'dendrogram', repel = FALSE, circular = TRUE,
ratio = 0.5) +
geom_edge_elbow() +
geom_node_text(aes(x = x*1.05, y=y*1.05,
angle = nAngle(x, y), label = label),
size=3, hjust='outward') +
geom_node_point(aes(leaf, color=species)) +
coord_fixed() +
ggforce::theme_no_axes()
ggraph(graph = irisDen2, layout = 'dendrogram', repel = FALSE, circular = TRUE,
ratio = 0.5) +
geom_edge_elbow() +
geom_node_text(aes(x = x*1.05, y=y*1.05,
angle = nAngle(x, y), label = label),
size=3, hjust='outward') +
geom_node_point(aes( color=species)) +
coord_fixed() +
ggforce::theme_no_axes()
ggraph(graph = irisDen2, layout = 'dendrogram', repel = FALSE, circular = TRUE,
ratio = 0.5) +
geom_edge_elbow() +
geom_node_text(aes(x = x*1.05, y=y*1.05,filter=leaf
angle = nAngle(x, y), label = label),
size=3, hjust='outward') +
geom_node_point(aes( filter=leaf,olor=species)) +
coord_fixed() +
ggforce::theme_no_axes()
ggraph(graph = irisDen2, layout = 'dendrogram', repel = FALSE, circular = TRUE,
ratio = 0.5) +
geom_edge_elbow() +
geom_node_text(aes(x = x*1.05, y=y*1.05, filter=leaf,
angle = nAngle(x, y), label = label),
size=3, hjust='outward') +
geom_node_point(aes(filter=leaf, color=species)) +
coord_fixed() +
ggforce::theme_no_axes()
?geom_node_text
ggraph(graph = irisDen2, layout = 'dendrogram', repel = FALSE, circular = TRUE,
ratio = 0.5) +
geom_edge_elbow() +
geom_node_text(aes(x = x*1.05, y=y*2.05, filter=leaf,
angle = nAngle(x, y), label = label),
size=3, hjust='outward') +
geom_node_point(aes(filter=leaf, color=species)) +
coord_fixed() +
ggforce::theme_no_axes()
ggraph(graph = irisDen2, layout = 'dendrogram', repel = FALSE, circular = TRUE,
ratio = 0.5) +
geom_edge_elbow() +
geom_node_text(aes(x = x*2.05, y=y*2.05, filter=leaf,
angle = nAngle(x, y), label = label),
size=3, hjust='outward') +
geom_node_point(aes(filter=leaf, color=species)) +
coord_fixed() +
ggforce::theme_no_axes()
ggraph(graph = irisDen2, layout = 'dendrogram', repel = FALSE, circular = TRUE,
ratio = 0.75) +
geom_edge_elbow() +
geom_node_text(aes(x = x*1.05, y=y*1.05, filter=leaf,
angle = nAngle(x, y), label = label),
size=3, hjust='outward') +
geom_node_point(aes(filter=leaf, color=species)) +
coord_fixed() +
ggforce::theme_no_axes()
ggraph(graph = irisDen2, layout = 'dendrogram', repel = FALSE, circular = TRUE,
ratio = 0.95) +
geom_edge_elbow() +
geom_node_text(aes(x = x*1.05, y=y*1.05, filter=leaf,
angle = nAngle(x, y), label = label),
size=3, hjust='outward') +
geom_node_point(aes(filter=leaf, color=species)) +
coord_fixed() +
ggforce::theme_no_axes()
ggraph(graph = irisDen2, layout = 'dendrogram', repel = FALSE, circular = TRUE,
ratio = 0.05) +
geom_edge_elbow() +
geom_node_text(aes(x = x*1.05, y=y*1.05, filter=leaf,
angle = nAngle(x, y), label = label),
size=3, hjust='outward') +
geom_node_point(aes(filter=leaf, color=species)) +
coord_fixed() +
ggforce::theme_no_axes()
ggraph(graph = irisDen2, layout = 'dendrogram', repel = FALSE, circular = TRUE,
ratio = 2.5) +
geom_edge_elbow() +
geom_node_text(aes(x = x*1.05, y=y*1.05, filter=leaf,
angle = nAngle(x, y), label = label),
size=3, hjust='outward') +
geom_node_point(aes(filter=leaf, color=species)) +
coord_fixed() +
ggforce::theme_no_axes()
ggraph(graph = irisDen2, layout = 'dendrogram', repel = FALSE, circular = TRUE,
ratio = 20.5) +
geom_edge_elbow() +
geom_node_text(aes(x = x*1.05, y=y*1.05, filter=leaf,
angle = nAngle(x, y), label = label),
size=3, hjust='outward') +
geom_node_point(aes(filter=leaf, color=species)) +
coord_fixed() +
ggforce::theme_no_axes()
ggraph(graph = irisDen2, layout = 'dendrogram', repel = FALSE, circular = TRUE,
ratio = 0.5) +
geom_edge_elbow() +
geom_node_text(aes(x = x*1.05, y=y*1.05, filter=leaf,
angle = nAngle(x, y), label = label),
size=3, hjust='outward') +
geom_node_point(aes(filter=leaf, color=species)) +
coord_fixed() +
ggforce::theme_no_axes()
?ggraph
install.packages("sparklyr")
library(sparklyr)
spark_install(version = "1.6.2")
sc <- spark_connect(master = "local")
library(dplyr)
iris_tbl <- copy_to(sc, iris)
flights_tbl <- copy_to(sc, nycflights13::flights, "flights")
batting_tbl <- copy_to(sc, Lahman::Batting, "batting")
flights_tbl %>% filter(dep_delay == 2)
delay <- flights_tbl %>%
group_by(tailnum) %>%
summarise(count = n(), dist = mean(distance), delay = mean(arr_delay)) %>%
filter(count > 20, dist < 2000, !is.na(delay)) %>%
collect()
library(ggplot2)
ggplot(delay, aes(dist, delay)) +
geom_point(aes(size = count), alpha = 1/2) +
geom_smooth() +
scale_size_area(max_size = 2)
batting_tbl %>%
select(playerID, yearID, teamID, G, AB:H) %>%
arrange(playerID, yearID, teamID) %>%
group_by(playerID) %>%
filter(min_rank(desc(H)) <= 2 & H > 0)
library(DBI)
iris_preview <- dbGetQuery(sc, "SELECT * FROM iris LIMIT 10")
mtcars_tbl <- copy_to(sc, mtcars)
partitions <- mtcars_tbl %>%
filter(hp >= 100) %>%
mutate(cyl8 = cyl == 8) %>%
sdf_partition(training = 0.5, test = 0.5, seed = 1099)
fit <- partitions$training %>%
ml_linear_regression(response = "mpg", features = c("wt", "cyl"))
summary(fit)
training <- as_h2o_frame(partitions$training)
test <- as_h2o_frame(partitions$test)
# Remove previous versions of h2o R package
if ("package:h2o" %in% search()) detach("package:h2o", unload=TRUE)
if ("h2o" %in% rownames(installed.packages())) remove.packages("h2o")
pkgs <- c("methods","statmod","stats","graphics",
"RCurl","jsonlite","tools","utils")
for (pkg in pkgs) {
if (!(pkg %in% rownames(installed.packages()))) install.packages(pkg)
}
install.packages("h2o", type = "source",
repos = "http://h2o-release.s3.amazonaws.com/h2o/rel-turing/6/R")
library(devtools)
devtools::install_github("h2oai/sparkling-water", subdir = "/r/rsparkling")
training <- as_h2o_frame(partitions$training)
test <- as_h2o_frame(partitions$test)
library(rsparkling)
training <- as_h2o_frame(partitions$training)
test <- as_h2o_frame(partitions$test)
h2o.init()
training <- as_h2o_frame(partitions$training)
test <- as_h2o_frame(partitions$test)
training <- as_h2o_frame(x = partitions$training)
training <- as_h2o_frame(sc = sc,x = partitions$training)
sc <- spark_connect("local", version = "1.6.2")
mtcars_tbl <- copy_to(sc, mtcars, "mtcars", overwrite = TRUE)
partitions <- mtcars_tbl %>%
filter(hp >= 100) %>%
mutate(cyl8 = cyl == 8) %>%
sdf_partition(training = 0.5, test = 0.5, seed = 1099)
training <- as_h2o_frame(sc, partitions$training)
test <- as_h2o_frame(sc, partitions$test)
glm_model <- h2o.glm(x = c("wt", "cyl"),
y = "mpg",
training_frame = training,
lambda_search = TRUE)
partitions <- h2o.splitFrame(as_h2o_frame(mtcars_tbl), 0.5))
partitions <- h2o.splitFrame(as_h2o_frame(mtcars_tbl), 0.5)
partitions <- h2o.splitFrame(data = as_h2o_frame(mtcars_tbl), 0.5)
library(sparklyr)
library(rsparkling)
library(dplyr)
sc <- spark_connect("local", version = "1.6.2")
mtcars_tbl <- copy_to(sc, mtcars, "mtcars", overwrite = TRUE)
partitions <- mtcars_tbl %>%
filter(hp >= 100) %>%
mutate(cyl8 = cyl == 8) %>%
sdf_partition(training = 0.5, test = 0.5, seed = 1099)
training <- as_h2o_frame(sc, partitions$training)
test <- as_h2o_frame(sc, partitions$test)
glm_model <- h2o.glm(x = c("wt", "cyl"),
y = "mpg",
training_frame = training,
lambda_search = TRUE)
print(glm_model)
library(ggplot2)
pred <- h2o.predict(glm_model, newdata = test)
# convert from H2O Frame to Spark DataFrame
predicted <- as_spark_dataframe(sc, pred)
actual <- partitions$test %>%
select(mpg) %>%
collect() %>%
`[[`("mpg")
data <- data.frame(
predicted = predicted,
actual    = actual
)
names(data) <- c("predicted", "actual")
ggplot(data, aes(x = actual, y = predicted)) +
geom_abline(lty = "dashed", col = "red") +
geom_point() +
theme(plot.title = element_text(hjust = 0.5)) +
coord_fixed(ratio = 1) +
labs(
x = "Actual Fuel Consumption",
y = "Predicted Fuel Consumption",
title = "Predicted vs. Actual Fuel Consumption"
)
library(dplyr)
sc <- spark_connect("local", version = "1.6.2")
iris_tbl <- copy_to(sc, iris, "iris", overwrite = TRUE)
iris_tbl
iris_hf <- as_h2o_frame(sc, iris_tbl)
kmeans_model <- h2o.kmeans(training_frame = iris_hf,
x = 3:4,
k = 3,
seed = 1)
h2o.centers(kmeans_model)
pca_model <- h2o.prcomp(training_frame = iris_hf,
x = 1:4,
k = 4,
seed = 1)
print(pca_model)
y <- "Species"
x <- setdiff(names(iris_hf), y)
iris_hf[,y] <- as.factor(iris_hf[,y])
splits <- h2o.splitFrame(iris_hf, seed = 1)
rf_model <- h2o.randomForest(x = x,
y = y,
training_frame = splits[[1]],
validation_frame = splits[[2]],
nbins = 32,
max_depth = 5,
ntrees = 20,
seed = 1)
h2o.confusionMatrix(rf_model, valid = TRUE)
h2o.varimp_plot(rf_model)
gbm_model <- h2o.gbm(x = x,
y = y,
training_frame = splits[[1]],
validation_frame = splits[[2]],
ntrees = 20,
max_depth = 3,
learn_rate = 0.01,
col_sample_rate = 0.7,
seed = 1)
h2o.confusionMatrix(gbm_model, valid = TRUE)
path <- system.file("extdata", "prostate.csv", package = "h2o")
prostate_df <- spark_read_csv(sc, "prostate", path)
head(prostate_df)
prostate_hf <- as_h2o_frame(sc, prostate_df)
splits <- h2o.splitFrame(prostate_hf, seed = 1)
y <- "VOL"
#remove response and ID cols
x <- setdiff(names(prostate_hf), c("ID", y))
dl_fit <- h2o.deeplearning(x = x, y = y,
training_frame = splits[[1]],
epochs = 15,
activation = "Rectifier",
hidden = c(10, 5, 10),
input_dropout_ratio = 0.7)
h2o.performance(dl_fit, newdata = splits[[2]])
splits <- h2o.splitFrame(prostate_hf, seed = 1)
y <- "VOL"
#remove response and ID cols
x <- setdiff(names(prostate_hf), c("ID", y))
gbm_params1 <- list(learn_rate = c(0.01, 0.1),
max_depth = c(3, 5, 9),
sample_rate = c(0.8, 1.0),
col_sample_rate = c(0.2, 0.5, 1.0))
gbm_grid1 <- h2o.grid("gbm", x = x, y = y,
grid_id = "gbm_grid1",
training_frame = splits[[1]],
validation_frame = splits[[1]],
ntrees = 100,
seed = 1,
hyper_params = gbm_params1)
gbm_gridperf1 <- h2o.getGrid(grid_id = "gbm_grid1",
sort_by = "mse",
decreasing = FALSE)
print(gbm_gridperf1)
gbm_params2 <- list(learn_rate = seq(0.01, 0.1, 0.01),
max_depth = seq(2, 10, 1),
sample_rate = seq(0.5, 1.0, 0.1),
col_sample_rate = seq(0.1, 1.0, 0.1))
search_criteria2 <- list(strategy = "RandomDiscrete",
max_models = 50)
gbm_grid2 <- h2o.grid("gbm", x = x, y = y,
grid_id = "gbm_grid2",
training_frame = splits[[1]],
validation_frame = splits[[2]],
ntrees = 100,
seed = 1,
hyper_params = gbm_params2,
search_criteria = search_criteria2)
gbm_params2 <- list(learn_rate = seq(0.01, 0.1, 0.01),
max_depth = seq(2, 10, 1),
sample_rate = seq(0.5, 1.0, 0.1),
col_sample_rate = seq(0.1, 1.0, 0.1))
search_criteria2 <- list(strategy = "RandomDiscrete",max_runtime_secs=60)
gbm_grid2 <- h2o.grid("gbm", x = x, y = y,
grid_id = "gbm_grid2",
training_frame = splits[[1]],
validation_frame = splits[[2]],
ntrees = 100,
seed = 1,
hyper_params = gbm_params2,
search_criteria = search_criteria2)
gbm_gridperf2 <- h2o.getGrid(grid_id = "gbm_grid2",
sort_by = "mse",
decreasing = FALSE)
gbm_gridperf2@summary_table[1,]
h2o.saveModel(my_model, path = "/Users/danny/h2omodels")
mod<-gbm_gridperf2@summary_table[1,]
h2o.saveModel(mod, path = "/Users/danny")
h2o.saveModel(dl_fit, path = "/Users/danny")
plot(cars)
plot(cars)
library(readr)
MAP_dat <- read_delim("~/Research/MAP/data/MAP_dat.tsv",
"\t", escape_double = FALSE, trim_ws = TRUE)
View(MAP_dat)
library(readr)
MAP_dat <- read_delim("~/Research/MAP/data/MAP_dat.tsv",
"\t", escape_double = FALSE, trim_ws = TRUE)
View(MAP_dat)
View(MAP_dat)
library(readxl)
GeoB20305_7_alldata <- read_excel("~/Research/MAP/data/GeoB20305-7_alldata.xlsx",
sheet = "Tabelle1")
View(GeoB20305_7_alldata)
library(readxl)
test <- read_excel("~/Research/MAP/data/GeoB20305-7_alldata.xlsx")
View(GeoB20305_7_alldata)
View(test)
setwd("~/Research/cvCells/macro-tests/in-grey-seg")
library(EBImage)
sp.sec<-"ipat"
refs.all <-list.files(pattern = paste0("*-g-",sp.sec))
segs.all <-list.files(pattern = paste0("*-g-",sp.sec))
beg = 1
end = as.numeric(length(refs.all))
for (i in beg:end){
# read and label segmented images
refs.array <-readImage(refs.all[i])
seg.array <-readImage(segs.all[i])
seg.labelled <-bwlabel(seg.array)
# contruct holders for feature-results
writer.1 <-paste0("shapes",i)
writer.2 <-paste0("textures",i)
# compute features
fts.shp <-computeFeatures(seg.labelled,refs.array)
fts.tex <-computeFeatures.haralick(seg.labelled,refs.array)
#--->
# can trim here or outside loop
#crt = which(fts[,6]>=10000) # size criteria here
#fts.trim = fts[crt,]
#--->
# assigning source file ids to rownames for completeness
rownames(fts.shp) <-rep(ref[i],dim(fts.shp)[1])
# use assign for each feature set
assign(writer.1,fts.shp)
assign(writer.2,fts.tex)
}
beg = 1
end = as.numeric(length(refs.all))
# short labels for meta-data
ref <-as.character(strsplit(refs.all,".tif"))
seg <-as.character(strsplit(segs.all,".tif"))
# main loop
for (i in beg:end){
# read and label segmented images
refs.array <-readImage(refs.all[i])
seg.array <-readImage(segs.all[i])
seg.labelled <-bwlabel(seg.array)
# contruct holders for feature-results
writer.1 <-paste0("shapes",i)
writer.2 <-paste0("textures",i)
# compute features
fts.shp <-computeFeatures(seg.labelled,refs.array)
fts.tex <-computeFeatures.haralick(seg.labelled,refs.array)
#--->
# can trim here or outside loop
#crt = which(fts[,6]>=10000) # size criteria here
#fts.trim = fts[crt,]
#--->
# assigning source file ids to rownames for completeness
rownames(fts.shp) <-rep(ref[i],dim(fts.shp)[1])
# use assign for each feature set
assign(writer.1,fts.shp)
assign(writer.2,fts.tex)
}
rm(list=ls(pattern = "^fts"))
pieces.shp <-Filter(function(x) is(x, "matrix"),mget(ls(pattern = "^shapes")))
pieces.tex <-Filter(function(x) is(x, "matrix"), mget(ls(pattern= "^textures")))
# construct lists
data.shapes <-do.call(rbind,pieces.shp)
data.textures <-do.call(rbind,pieces.tex)
crt <-which(data.shapes[,6]>=10000) # size criteria here
data.shapes.trim <-data.shapes[crt,] # apply to shape data
data.textures.trim <-data.textures[crt,] # apply for textures
# bind rows for full array of features
array.images <-cbind(data.shapes.trim,data.textures.trim)
write.csv(array.images,file = paste0 ("array",sp.sec".csv"),row.names = TRUE)
write.csv(array.images,file = paste0 ("array",sp.sec,".csv"),row.names = TRUE)
write.csv(array.images,file = paste0 ("array","-",sp.sec,".csv"),row.names = TRUE)
rm(list = ls(pattern = "^shapes"))
rm(list = ls(pattern = "^textures"))
# Write out data-sets
library(stringr)
library(magrittr)
array.ipat.dfs <-as.data.frame(array.images)
# create a column of image-names
rNames <-rownames(array.ipat.dfs)
rNames.tag <-str_sub(rNames,-4)
array.ipat.dfs %<>% cbind(rNames.tag,.)
save(array.ipat.dfs,file="array-ipat.Rdata")
library(FFTrees)
library(dplyr)
library(magrittr)
load("array-bspp.Rdata")
load("array-iacu.Rdata")
load("array-snep.Rdata")
load("array-squa.Rdata")
load("array-ipat.Rdata")
join.df<-rbind(array.bspp.dfs,array.iacu.dfs,array.snep.dfs,array.squa.dfs,array.ipat.dfs)
sp.1<-"iacu"
sp.2<-"ipat"
join.df.bin <- join.df %>%  filter(.,rNames.tag == sp.1 | rNames.tag == sp.2)
join.df.bin$tagBinary <- 0
join.df.bin$tagBinary[join.df.bin$rNames.tag == sp.2] <- 1
array.fft <- FFTrees(formula = tagBinary ~.,
data = join.df.bin[,2:117])
array.fft
View(join.df.bin)
plot(array.fft,
main = "Dino FFT",
decision.names = c(sp.1, sp.2))
library(caret)
library(AppliedPredictiveModeling)
# using untrimmed data: join.df
transparentTheme(trans = .9)
featurePlot(x = join.df[, 91:100],
y = join.df$rNames.tag,
plot = "density",
## Pass in options to xyplot() to
## make it prettier
scales = list(x = list(relation="free"),
y = list(relation="free")),
adjust = 1.5,
pch = "|",
layout = c(5, 2),
auto.key = list(columns = 2))
featurePlot(x = join.df[, 91:100],
y = join.df$rNames.tag,
plot = "density",
## Pass in options to xyplot() to
## make it prettier
scales = list(x = list(relation="free"),
y = list(relation="free")),
adjust = 1.5,
pch = "|",
layout = c(5, 2),
auto.key = list(columns = 2),col=c("red","orange","blue","green","black"))
featurePlot(x = join.df[, 91:100],
y = join.df$rNames.tag,
plot = "density",
## Pass in options to xyplot() to
## make it prettier
scales = list(x = list(relation="free"),
y = list(relation="free")),
adjust = 1.5,
pch = "|",
layout = c(5, 2),
auto.key = list(columns = 2,col=c("red","blue","green","orange","purple")),
col=c("red","blue","green","orange","purple"))
featurePlot(x = join.df[, 91:100],
y = join.df$rNames.tag,
plot = "density",
## Pass in options to xyplot() to
## make it prettier
scales = list(x = list(relation="free"),
y = list(relation="free")),
adjust = 1.5,
pch = "|",
layout = c(5, 2),
auto.key = list(columns = 2))
